<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[post数论板子(待补充)]]></title>
    <url>%2F2019%2F06%2F02%2Fpost%E6%95%B0%E8%AE%BA%E6%9D%BF%E5%AD%90-%E5%BE%85%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[1，最大公约数最小公倍数 123456789int gcd(int a, int b)&#123; if(a&lt;b)&#123;int t=a;a=b;b=t;&#125; return a%b==0?b:gcd(b,a%b);&#125;int lcm(int a, int b)&#123; return a/gcd(a,b)*b;&#125; 2,快速幂取模（ Montgomery算法） 1234567891011__int64 qpow(int a,int b,int r)//快速幂 &#123; __int64 ans=1,buff=a; while(b) &#123; if(b&amp;1)ans=(ans*buff)%r; buff=(buff*buff)%r; b&gt;&gt;=1; &#125; return ans;&#125; 3,费马小定理 1234567long long pow(long long n, long long k) &#123; if (k == 0) return 1; if (k == 1) return n; long long ans = pow(n * n % p, k&gt;&gt;1); if (k&amp;1) ans = ans * n % p; return ans;&#125; 4，中国剩余定理 123456789101112131415161718192021void exgcd(int a,int b,int &amp;x,int &amp;y)&#123; if(b==0)&#123; x=1; y=0; return;&#125; exgcd(b,a%b,x,y); int tp=x; x=y; y=tp-a/b*y;&#125;int china()&#123; int ans=0,lcm=1,x,y; for(int i=1;i&lt;=k;++i) lcm*=b[i]; for(int i=1;i&lt;=k;++i) &#123; int tp=lcm/b[i]; exgcd(tp,b[i],x,y); x=(x%b[i]+b[i])%b[i];//x要为最小非负整数解 ans=(ans+tp*x*a[i])%lcm; &#125; return (ans+lcm)%lcm;&#125; 拓展中国定理 所以整个算法的思路就是求解k次扩展欧几里得 1234567891011121314151617181920212223242526lt exgcd(lt a,lt b,lt &amp;x,lt &amp;y)&#123; if(b==0)&#123;x=1;y=0;return a;&#125; lt gcd=exgcd(b,a%b,x,y); lt tp=x; x=y; y=tp-a/b*y; return gcd;&#125;lt excrt()&#123; lt x,y,k; lt M=bi[1],ans=ai[1]; for(int i=2;i&lt;=n;i++) &#123; lt a=M,b=bi[i],c=(ai[i]-ans%b+b)%b; lt gcd=exgcd(a,b,x,y),bg=b/gcd; if(c%gcd!=0) return -1; x=mul(x,c/gcd,bg); ans+=x*M; M*=bg; ans=(ans%M+M)%M; &#125; return (ans%M+M)%M;&#125; 5，素数筛法 6，拓展欧几里得 7，求逆元 8，欧拉函数 9,求n^k的前三位数和后三位数 10，特殊数字 12345678910111213#include&lt;stdio.h&gt;int main()&#123; __int64 s[51]=&#123;0,1&#125;; int i; for(i=2;i&lt;=50;i++) s[i]=s[i-2]+s[i-1]; int n; while(scanf("%d",&amp;n)&amp;&amp;(n!=-1)) printf("%I64d\n",s[n]); return 0; &#125; 12345678910111213141516171819#include&lt;stdio.h&gt;int main()&#123; __int64 a[36]; int i,j; a[1]=1; for(i=2;i&lt;=35;i++) a[i]=a[i-1]*1.0/(i+1)*(4*i-2); int n; int x=1; while(scanf("%d",&amp;n)) &#123; if(n==-1) break; printf("%d %d %I64d\n",x,n,2*a[n]); x++; &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;stdio.h&gt;int main()//斯特灵数 &#123; char *w[100]; int n; w[1]="1"; w[2]="3"; w[3]="13"; w[4]="75"; w[5]="541"; w[6]="4683"; w[7]="47293"; w[8]="545835"; w[9]="7087261"; w[10]="102247563"; w[11]="1622632573"; w[12]="28091567595"; w[13]="526858348381"; w[14]="10641342970443"; w[15]="230283190977853"; w[16]="5315654681981355"; w[17]="130370767029135901"; w[18]="3385534663256845323"; w[19]="92801587319328411133"; w[20]="2677687796244384203115"; w[21]="81124824998504073881821"; w[22]="2574844419803190384544203"; w[23]="85438451336745709294580413"; w[24]="2958279121074145472650648875"; w[25]="106697365438475775825583498141"; w[26]="4002225759844168492486127539083"; w[27]="155897763918621623249276226253693"; w[28]="6297562064950066033518373935334635"; w[29]="263478385263023690020893329044576861"; w[30]="11403568794011880483742464196184901963"; w[31]="510008036574269388430841024075918118973"; w[32]="23545154085734896649184490637144855476395"; w[33]="1120959742203056268267494209293006882589981"; w[34]="54984904077825684862426868390301049750104843"; w[35]="2776425695289206002630310219593685496163584253"; w[36]="144199280951655469628360978109406917583513090155"; w[37]="7697316738562185268347644943000493480404209089501"; w[38]="421985466101260424678587486718115935844245187819723"; w[39]="23743057231588741419119534567705900419786127935577533"; w[40]="1370159636942236704917645663312384364386256449136591915"; w[41]="81045623051154285047127402304207782853156976521592907421"; w[42]="4910812975389574954318759599939388855544783946694910718603"; w[43]="304646637632091740261982544696657582136519552428876887346813"; w[44]="19338536506753895707368358095646384573117824953447578202397675"; w[45]="1255482482235481041484313695469155949742941807533901307975355741"; w[46]="83318804148028351409201335290659562069258599933450396080176273483"; w[47]="5649570401186486930330812460375430692673276472202704742218853260093"; w[48]="391229145645351175841837029639030040330277058716846008212321196523435"; w[49]="27656793065414932606012896651489726461435178241015434306518713649426461"; w[50]="1995015910118319790635433747742913123711612309013079035980385090523556363"; while(~scanf("%d",&amp;n)) printf("%s\n",w[n]); return 0;&#125; 11,同余定理]]></content>
      <tags>
        <tag>数论</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello hexo]]></title>
    <url>%2F2019%2F05%2F30%2Fhello-hexo%2F</url>
    <content type="text"><![CDATA[哇咔咔]]></content>
  </entry>
</search>
