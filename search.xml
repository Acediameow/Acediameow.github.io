<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[紫书 2019.10.9]]></title>
    <url>%2F2019%2F10%2F10%2F%E7%B4%AB%E4%B9%A6-2019-10-9%2F</url>
    <content type="text"><![CDATA[紫书习题3道 2019.10.9无话可说，紫书不愧是你 我是真的布吉岛这个玩意咋写，就先这么呆着吧QAQ。 no.1 uva202就是寻找循环节，在除法计算的过程中判断一个循环节是否出现，而循环节的第二次出现意味着计算过程中的余数出现了第二次。举例1/3，商是0（在c语言里），代表这个除法的整数部分是0，余数是1，再乘10，得到的10作为第一步的分子，10/3的商是3，代表这个除法的第一位小数是3，余数是1，然后接下来也是这种步骤。 可以发现每步的除法只跟分子有关，也就是当分子出现重复值，便出现了循环节。 在程序的实现过程中，可以不用存储余数的值，只用存储分子和商，定义了二维数组，s[0] [i]存储第i步的分子，s[1] [i]存储第i步的商 Bjyx()用来找i位之前是否有重复分子出现，有则返回周期len 之后就是基操enmmmm，需要注意的是分子的计算用s[0] [q] = (A[0] [q-1] - b A[1] [q-1])10 ;这样可以避免a/b = 0，从而不使用%来取得余数 然后注意输出格式，不然会pe 还xiao习到了可以用巢鸽原理（抽屉原理,狄利克雷原则）： 简单的描述：如果有n个笼子，n+1只鸽子居住，则至少有一个笼子有两只鸽子。 一般化的描述（用高斯函数来叙述）：将n个元素分到m个集合中，至少有一个集合中元素个数大于等于[(n-1)/m]+1 。 对于本题，a%b最多有b-1个情况，根据巢鸽原理，循环节数小于等于b-1. 还可以考虑一下用gcd对分数化简 （大概没什么好说的了吧23333） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 2005 ;int s[2][maxn] ;int a , b , i , len , p , q ;int Bjyx()&#123; for(p = 1 ; p &lt; q ; ++p) &#123; if(s[0][p] == s[0][q]) return q - p ; &#125; return -1 ;&#125;int main()&#123; while(cin &gt;&gt; a &gt;&gt; b) &#123; s[0][0] = a ; s[1][0] = a / b ; for(q = 1 ; ; ++q) &#123; s[0][q] = (s[0][q - 1] - b * s[1][q - 1]) * 10 ; s[1][q] = s[0][q] / b ; len = Bjyx() ; if(len &gt; 0) break ; &#125; printf("%d/%d = %d.", a , b , s[1][0]) ; for(int i = 1; i &lt; p; ++i) &#123; printf("%d", s[1][i]) ; &#125; printf("(") ; for(int i = p ; i &lt; q ; ++i) &#123; if(i &gt; 50) &#123; printf("...") ; break ; &#125; printf("%d", s[1][i]) ; &#125; printf(")\n %d = number of digits in repeating cycle\n\n" , len) ; &#125; return 0;&#125; no.2 uva1588enmmm大概就是求新长条的最长的长度 可以先将一个长条a固定，将另外一个长条b依次后移，b移动不了就以b为基准固定，然后移动a。 由题可知，长条不能被翻转或者是旋转，所以只能从左往右移动，并且不用将长条逆置，这样的话只用扫描两次就可以了。 这道题主要是控制边界，例如i + j &lt; lena，要不然最大长度会比正常的长一点。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 1e5 + 5 ;int main()&#123; char sa[maxn] , sb[maxn] ; while(cin &gt;&gt; sa &gt;&gt; sb) &#123; int i ; int a[maxn] , b [maxn] ; int lena = strlen(sa) ; int lenb = strlen(sb) ; for(i = 0 ; i &lt; lena; ++i) &#123; a[i] = sa[i] - '0' ; &#125; for(i = 0 ; i &lt; lenb ; ++i) &#123; b[i] = sb[i] - '0' ; &#125; for(i = 0 ; i &lt; lena ; ++i) &#123; int flag = 1 ; for(int j = 0 ; j &lt; lenb &amp;&amp; i + j &lt; lena ; ++j) // 注意处理边界问题 &#123; if(a[i + j] + b[j] == 4) &#123; flag = 0 ; break ; &#125; &#125; if(flag == 1) break ; &#125; int ans1 = max(lena , lenb + i) ; for(i = 0 ; i &lt; lenb ; ++ i) &#123; int flag = 1 ; for(int j = 0 ; j &lt; lena &amp;&amp; i + j &lt; lenb ; ++j) &#123; if(a[j] + b[i + j] == 4) &#123; flag = 0 ; break ; &#125; &#125; if(flag == 1) break ; &#125; int ans2 = max(lena + i , lenb) ; int minn = min(ans1 , ans2) ; cout &lt;&lt; minn &lt;&lt; endl ; &#125; return 0 ;&#125; no.3 uva 11809。。。这题我绝对踩着时间过得。。。忽然好奇输入是个什么妖魔鬼怪。 有题目可得公式 之后由于数字过大无法存储，所以对等式两边同时求以10为底的对数，则公式可以化为 这道题还是要注意精度的。double，float对于逻辑运算符 == 基本无用。两数是否相等，应采用如fabs(a-b)&lt;eps的方式，这道题中eps我取的1e-6,但是1e-5,1e-4应该都阔以。 我还是好奇if(a == 0 &amp;&amp; b == 0)那个放到下面为啥就过了，好奇数据.jpg. 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std ;typedef long long ll ;const double eps = 1e-5;int main()&#123; double a , b , m , n ; while(scanf("%17lfe%lf" , &amp;a , &amp;b) != EOF) &#123; if(a == 0 &amp;&amp; b == 0) break ; int flag = 0 ; for(int i = 0 ; i &lt; 10 ; ++ i) &#123; for(int j = 1 ; j &lt; 31 ; ++ j) &#123; m = 0.0 ; n = 0.0 ; for(int x = 1 ; x &lt; i + 2 ; ++ x) &#123; m ++ ; m /= 2 ; &#125; for(int y = 1 ; y &lt; j + 1 ; ++ y) &#123; n *= 2 ; n ++ ; &#125; if(abs((log(a) + b * log(10)) - (log(m) + n * log(2))) &lt; eps) &#123; printf("%d %d\n" , i , j) ; flag = 1 ; break ; &#125; &#125; if(flag == 1) break ; &#125; &#125; return 0 ;&#125; 弱小孤独无助又能吃.jpg 委屈巴巴.jpg]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F06%2F22%2F%E5%BA%9F%E8%AF%9D%E4%B8%8D%E5%A4%9A%E8%AF%B4%E4%BA%86%EF%BC%8Cc%E8%AF%AD%E8%A8%80%E5%A4%A7%E4%BD%9C%E4%B8%9A%E4%BB%A3%E7%A0%81%20%2B%201%2F</url>
    <content type="text"><![CDATA[废话不多说了，c语言大作业代码 + 12019河北省赛的D题，榜单的简易版 23333我不会告诉你们盟盟的题册是我给的hhh 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define minn(a,b) a &gt; b ? a : b ;struct Student&#123; char name[50]; int solve ; int pro[20] ; int pass[20] ; int ifdo[20] ; bool sub ; bool vis ;&#125;team[5005],temp;int bianli(char *m, int n)&#123; int i; for(i = 1; i &lt;= n; ++ i) &#123; if(strcmp(team[i].name,m) == 0 ) return i ; &#125; return 0 ;&#125;int Penalty(Student a,int n)&#123; int i ; int sum = 0 ; for(i = 1; i &lt; n + 1 ; ++ i ) &#123; if(a.ifdo[i] != 0 &amp;&amp; a.pass[i] &gt;= 0 ) sum += a.pro[i]; &#125; return sum ;&#125;int Same(Student a , Student b , int n)&#123; if(Penalty(a,n) == Penalty(b,n) &amp;&amp; a.solve == b.solve) return 1 ; else return 0 ;&#125;void Print(Student *team , int n , int near , int cnt )&#123; int i , k ; printf("Rank Who Solved Penalty"); for(i = 0 ; i &lt; n ; ++ i) printf(" %c",i + 'A') ; printf("\n") ; for(i = 1; i &lt; cnt + 1 ; ++ i) &#123; if(team[i].vis == 0) break ; else &#123; if(Same(team[i],team[i - 1],n)) printf("%4d",near); else &#123; near = i ; printf("%4d",i) ; &#125; &#125; printf(" %43s",team[i].name) ; printf(" %6d",team[i].solve) ; printf(" %7d",Penalty(team[i],n)) ; for(k = 1 ; k &lt; n + 1 ; ++ k) &#123; if(team[i].ifdo[k] == 0) printf(" "); else &#123; if(team[i].pass[k] &gt; 0) printf(" +%d",team[i].pass[k]) ; if(team[i].pass[k] &lt; 0) printf(" %d",team[i].pass[k]) ; if(team[i].pass[k] == 0) printf(" +") ; &#125; &#125; printf("\n") ; &#125;&#125;void Sort(Student *team , int cnt , int n)&#123; int i , j ; for(i = 1 ; i &lt; cnt + 1; ++ i) &#123; for(j = 1 ; j &lt; cnt - i + 1 ; ++ j) &#123; if(team[j].solve &lt; team[j + 1].solve) &#123; temp = team[j] ; team[j] = team[j + 1] ; team[j + 1] = temp ; &#125; if(team[j].solve == team[j + 1].solve ) &#123; if(Penalty(team[j],n) &gt; Penalty(team[j + 1],n)) &#123; temp = team[j] ; team[j] = team[j + 1] ; team[j + 1] = temp ; &#125; if(Penalty(team[j],n) == Penalty(team[j + 1],n)) &#123; if(strcmp(team[j].name,team[j + 1].name) &gt; 0 ) &#123; temp = team[j] ; team[j] = team[j + 1] ; team[j + 1] = temp ; &#125; &#125; &#125; &#125; &#125;&#125;int main(void)&#123; int n, cnt, flag, near, t, num, i, j,nextpos; int zhuang[10] ; char m[205], nowteam[50]; char zhuangtai[10][30] = &#123;"Accepted ","Wrong Answer ","Time Limit Exceeded ", "Compile Error ", "Memory Limit Exceeded ", "Output Limit Exceeded ", "Runtime Error ", "Presentation Error "&#125; ; Student temp ; scanf("%d",&amp;n) ; getchar() ; cnt = 0 ; near = -1 ; while(gets(m) &amp;&amp; m[0] != 'G') &#123; t = ((m[0] - '0') * 10 + (m[1] - '0')) * 60 + (m[3] - '0') * 10 + (m[4] - '0'); num = m[6] - 'A' + 1; memset(zhuang , 0 , sizeof (zhuang)) ; for(i = 0 ; i &lt; 8 ; ++ i) zhuang[i] = strlen(zhuangtai[i]) ; if (m[8] == 'A') nextpos = 8 + zhuang[0] ; if (m[8] == 'W') nextpos = 8 + zhuang[1] ; if (m[8] == 'T') nextpos = 8 + zhuang[2] ; if (m[8] == 'C') continue; if (m[8] == 'M') nextpos = 8 + zhuang[4] ; if (m[8] == 'O') nextpos = 8 + zhuang[5] ; if (m[8] == 'R') nextpos = 8 + zhuang[6] ; if (m[8] == 'P') nextpos = 8 + zhuang[7] ; strcpy(nowteam , m + nextpos); flag = bianli(nowteam,cnt); if(flag == 0 ) &#123; flag = ++ cnt; team[flag].sub = 1; strcpy(team[flag].name , nowteam) ; if(m[8] == 'A') &#123; team[flag].pro[num] += t ; team[flag].pass[num] = 0 ; team[flag].solve += 1 ; &#125; else &#123; team[flag].pro[num] += 20 ; team[flag].pass[num] -= 1 ; &#125; &#125; else &#123; if(team[flag].pass[num] &gt; 0) break ; if(m[8] == 'A') &#123; team[flag].pro[num] += t ; team[flag].pass[num] *= -1 ; team[flag].solve += 1 ; &#125; else &#123; team[flag].pro[num] += 20 ; team[flag].pass[num] -= 1 ; &#125; &#125; team[flag].ifdo[num] = 1 ; team[flag].vis = 1 ; &#125; Sort(team , cnt ,n) ; Print(team , n , near , cnt) ; return 0 ;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[hello hexo]]></title>
    <url>%2F2019%2F05%2F30%2Fhello-hexo%2F</url>
    <content type="text"><![CDATA[哇咔咔]]></content>
  </entry>
</search>
